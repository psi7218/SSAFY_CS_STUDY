Webpack vs Vite

# Webpack vs Vite: 개념과 비교 정리

## ✅ Webpack이란?

Webpack은 JS, CSS, 이미지 등 다양한 자원을 하나 또는 여러 개의 번들 파일로 묶어주는 모듈 번들러(Module Bundler)이다.
→ 브라우저가 이해할 수 있는 하나의 JS 파일로 변환해준다.

### 주요 목적

- 의존성 관리 (import/export)
- 정적 리소스 통합 (이미지, CSS, 폰트 등)
- **브라우저가 처리 가능한 형태로 변환**
- 최적화 (Tree Shaking, Code Splitting 등)

### 번들링이란?

- 여러 개의 파일(모듈)을 하나 또는 몇 개의 파일로 합치는 과정

### 왜 번들링을 하는가?

#### 📌 이유 1. 브라우저는 수백 개의 JS 파일을 잘 처리하지 못함

- 많은 파일을 하나씩 요청하면 HTTP 요청 수가 너무 많아져서 느려짐
  → 요청 수를 줄이는 것이 핵심 목표

#### 📌 이유 2. 의존성 자동 관리

- import / require 기반으로 자동으로 의존성을 찾아 하나로 묶음

#### 📌 이유 3. 최신 문법은 브라우저가 바로 이해 못 함

- ES6, JSX, TS 등은 Babel + 번들러로 변환 필요

#### 📌 이유 4. 성능 최적화

- Tree shaking으로 불필요한 코드 제거
- Code Splitting, Lazy loading으로 로딩 최적화

---

## ✅ Webpack 주요 개념

- **Entry**: 번들링 시작점 (ex: `index.js`)
- **Dependency Graph**: 의존성 트리 구성
- **Loaders**: JS가 아닌 파일(CSS, 이미지 등)을 JS로 변환
- **Plugins**: 번들 최적화, HTML 생성, 환경변수 주입 등
- **Output**: 최종 번들 결과 위치 및 파일명
- **Mode**: development / production 모드 설정

### Webpack 동작 순서

1. Entry 파일에서 시작
2. 모든 의존성 분석
3. Loader로 변환
4. Plugin 적용
5. Output으로 결과물 저장

### 중복 모듈 제거

- 동일한 모듈은 번들에 한 번만 포함됨 → 내부적으로 고유 ID로 처리

---

## ✅ Code Splitting in Webpack

```jsx
const PageA = lazy(() => import("./PageA"));
```

- Webpack은 `import()`를 만나면 해당 모듈을 별도 청크로 분리
- 필요 시점에 네트워크 요청으로 해당 파일을 로드
- 성능 향상, 캐싱 효율 ↑

### 정적 vs 동적 스플리팅

- entry-based splitting: webpack.config에서 설정
- dynamic import-based splitting: 실제 코드에서 `import()` 사용 → 일반적으로 더 많이 사용

---

## ✅ Vite란?

Vite는 빠른 개발 환경을 위해 만들어진 빌드 도구이며, **ESM 기반 개발 서버 + Rollup 기반 빌드 도구**이다.

### 주요 철학

> 개발은 빠르게 (esbuild)
> 배포는 최적화되게 (Rollup)

### Vite의 핵심 특징

- 브라우저가 직접 `import`를 따라가며 모듈 요청 (개발 중)
- CommonJS 라이브러리 등은 브라우저가 읽기 어려움 → 이를 위해 "Pre-bundling" 수행

### Pre-Bundling이란?

- `node_modules`의 외부 의존성을 esbuild로 미리 한 번 번들링
- `.vite/deps`에 저장
- 브라우저는 딱 한 번의 요청으로 react 등 모든 의존성 로딩 가능

---

## ✅ Vite vs Webpack: 코드 스플리팅 동작

| 항목             | Webpack                     | Vite                                         |
| ---------------- | --------------------------- | -------------------------------------------- |
| 개발 중 스플리팅 | 미리 청크 생성 (내부적으로) | 브라우저가 요청 시 파일 단위로 네트워크 요청 |
| 동작 원리        | 전체 트리 번들링 후 제공    | 개별 모듈을 브라우저가 직접 import함         |

```jsx
// App.jsx
const PageA = lazy(() => import("./PageA"));
```

- Webpack: PageA import 시 미리 청크 생성
- Vite: 브라우저가 직접 `GET /src/PageA.jsx` 요청

---

## ✅ 개발 서버 속도 차이

| 항목           | Webpack                | Vite                            |
| -------------- | ---------------------- | ------------------------------- |
| 실행 구조      | 전체 트리 분석 후 시작 | import 되는 모듈만 요청 시 처리 |
| HMR 속도       | 느림 (전체 재분석)     | 빠름 (변경된 모듈만 갱신)       |
| 서버 시작 속도 | 느림                   | 매우 빠름                       |

---

## ✅ 빌드 시 구조 차이

- Webpack: Webpack 번들링
- Vite: Rollup 기반 번들링 (모듈 단위 최적화)

---

## ✅ 언제 Webpack을 써야 하나?

| 상황                    | 이유                                         |
| ----------------------- | -------------------------------------------- |
| 레거시 시스템           | 기존에 Webpack으로 구성된 프로젝트 유지보수  |
| 구형 브라우저 (IE) 지원 | ESM 기반 도구는 IE 지원 어려움               |
| 복잡한 커스터마이징     | Module Federation, 복잡한 플러그인 체계      |
| 대기업 전통 구조        | 사내 규칙 및 플랫폼 표준으로 Webpack 사용 중 |

---

## ✅ 언제 Vite를 써야 하나?

| 상황                 | 이유                                             |
| -------------------- | ------------------------------------------------ |
| 새로운 프로젝트      | 설정 거의 없이 빠른 개발 가능                    |
| 최신 브라우저 대상   | ESM + 빠른 개발 서버                             |
| SPA                  | 모듈 기반 구성에 최적화됨                        |
| 모던 프레임워크 사용 | SvelteKit, Nuxt 3, Astro 등 기본적으로 Vite 사용 |

---

## ✅ 요약 비교표

| 비교 항목           | Webpack     | Vite                                   |
| ------------------- | ----------- | -------------------------------------- |
| 번들 방식           | 항상 번들링 | dev는 ESM import, prod는 Rollup 번들링 |
| 개발 서버 속도      | 느림        | 매우 빠름                              |
| HMR 속도            | 느림        | 매우 빠름 (ms 단위)                    |
| 설정 난이도         | 높음        | 낮음 (기본값 우수)                     |
| SSR 프레임워크 연계 | Next.js 등  | SvelteKit, Astro                       |
| 구형 브라우저 호환  | 가능        | 어려움                                 |
| 커스터마이징 유연성 | 매우 높음   | 제한적이지만 충분함                    |

---
