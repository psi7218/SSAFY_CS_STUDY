- **Checked Exception과 Unchecked Exception의 차이점**
    
    **Checked Exception**
    실행하기 전에 예측 가능한 예외로, 반드시 예외 처리 해야 함. (IOException, ClassNotFoundException 등)
    
    **Unchecked Exception**
    실행하고 난 후에 알 수 있는 예외로, 따로 예외처리 하지 않아도 됨. (NullPointerException, ArrayIndexOutOfBoundException 등)
    
    RuntimeException은 UncheckedException을 상속한 클래스이고, RuntimeException이 아닌 것은 CheckedException을 상속한 클래스
    
<br/>

- **멀티스레딩과 동기화**
    
    **멀티스레드**
    
    하나의 프로세스 내에서 2개 이상의 스레드(실행 흐름의 단위)가 존재해 동시에 여러 작업을 수행하는 것.
    여러 작업을 동시에 처리하는 병렬 처리로 CPU 활용을 극대화하고, 하나의 프로세스 내에서 자원을 공유하므로 효율적인 자원 사용이 가능함.
    단, 여러 스레드가 공유 자원에 접근하면 데이터 충돌이 발생하는 동기화 문제가 발생할 수 있음.
    
    **동기화**
    
    멀티스레딩 환경에서 여러 스레드가 공유 자원에 동시 접근할 때, 데이터가 충돌할 수 있기에 한 번에 하나의 스레드만 특정 코드를 실행하도록 제한 하는 것. synchronized 또는 Lock을 사용해 해결.
    
<br/>

- **리플렉션(Reflection)**
    
    클래스의 구체적인 타입을 알지 못해도 컴파일 시점이 아닌 런타임에 클래스, 메서드, 필드 등의 정보를 동적으로 분석하고 조작(바인딩)할 수 있도록 하는 자바 API.
    
    단, 컴파일 시점이 아닌 런타임에 정보를 찾고 실행하므로 속도가 느리고, 코드 흐름 파악이 어려워 디버깅이 복잡함.
    
    intelliJ의 자동완성 기능, 스프링의 어노테이션과 의존성 주입이 리플렉션을 이용한 가능이라 할 수 있음
    
<br/>

- **추상클래스와 인터페이스 정의 및 사용용도**
    
    **추상클래스**
    
    클래스 내 추상 메서드가 하나 이상 포함되거나 abstract로 선언한 클래스. extends 키워드 사용해 단일 상속만 가능.
    
    - 공통된 기능을 제공하면서도 하위 클래스마다 다르게 동작해야 하는 경우에 사용
    
    **인터페이스**
    
    모든 메서드가 추상 메서드로만 이루어져 있는 것. implements 키워드 사용해 다중 상속 가능.
    
    - 구현할 메서드를 강제해 일관된 동작 보장, 객체 간 결합도 낮추고 확장성 높임
    
    공통점 : 사용하기 위해서는 자식 클래스에서 확장 및 구현 해야 함.
    
<br/>

- **static 변수는 언제 메모리에 할당되는가?**
    
    클래스가 처음 로드될 때 (JVM이 클래스 파일을 메모리에 적재할 때) **메서드 영역**에 할당되고, GC 관리 영역 밖에 있어 프로그램 종료시까지 메모리에 값이 유지됨.
    
    new 키워드와 무관하게 객체 생성 전에도 사용 가능
    
<br/>

- **Array, ArrayList, LinkedList의 차이**
    1. Array : 동일한 데이터 타입의 집합
    2. ArrayList : 자바 컬렉션 프레임워크에서 List 인터페이스에 속하며, 순서가 있고, 중복이 허용되며, 배열과 달리 삽입/삭제 메서드가 존재. 자료 탐색에 용이
    3. LinkedList : ArrayList의 단점 보완위해 등장한 것으로, 연결된 노드 간의 집합을 의미. 노드는 데이터와 포인터를 포함해 포인터는 노드의 앞/뒤 위치를 저장. 삽입/삭제가 빈번할 경우 사용하면 좋음

<br/>

- **Java의 실행 과정**
    1. 자바 파일을 컴파일러를 통해 .class 파일로 변환
    2. .class 파일을 JVM의 클래스로더에게 보냄
    3. 클래스로더에서 JVM 런타임 영역으로 할당해 메모리에 올림
    4. JVM 실행 엔진을 통해 실행

<br/>

- **가비지 컬렉터(GC)**
    
    **가비지 컬렉터**
    
    자동으로 JVM의 메모리를 관리하는 역할, heap 영역에 동적으로 할당된 메모리 영역 중 필요없어진 객체를 회수.
    
    **가비지 컬렉션**
    
    가비지 컬렉터가 이를 인식하고 메모리에서 제거하는 백그라운드 작업(Stop the world - Mark and Sweep)
    
    단점 : GC 실행 시 모든 쓰레드가 멈추므로 실시간 성능 저하가 발생할 수 있음.
    
<br/>

- **객체 지향 프로그래밍(OOP)**
    
    프로그램 구현에 필요한 객체를 파악하고, 필요한 데이터와 동작을 독립된 단위인 객체로 만들어 구현. 코드의 재활용성 및 디버깅이 쉽다는 장점이 있음. 대표적으로 C++, Java, Python
    
    1. 캡슐화
        
        객체에 대해 외부 접근을 막는 것으로, 정보 은닉을 통해 보안성과 유지보수성을 높임. private 키워드 사용해 데이터 은닉, getter setter 통해 접근
        
    2. 상속
        
        부모 클래스의 기능을 자식 클래스가 물려받아 사용하는 것으로, 코드 재사용성을 증가시키고 유지보수성을 높임. extends 키워드 사용해 상속 구현
        
    3. 다형성
        
        하나의 인터페이스 또는 부모 클래스 기반으로 여러 형태를 가지는 것. 같은 메서드 이름이지만, 동작 방식이 달라짐. 오버로딩/오버라이딩
        
    4. 추상화
        
        객체들이 공통적으로 필요로 하는 속성이나 동작 하나로 추출해 정의하는 것
        
        추상 클래스(일부 메서드는 구현하고, 일부는 추상 메서드로 남겨두는 클래스)
        인터페이스(모든 메서드가 구현 없이 선언만 되어 있는 형태)
        
<br/>

- **SOLID 원칙**
    
    객체지향 설계의 원칙으로 5가지로 구성되어 있음
    
    1. SRP(단일 책임 원칙) : 한 클래스는 하나의 책임만 가져야 한다.
    2. OCP(개방-폐쇄 원칙) : 확장에는 열려있고, 수정에는 닫혀있어야 한다.
    3. LSP(리스코프 치환 원칙) : 하위 타입은 항상 상위 타입을 대체 할 수 있어야 한다.
    4. ISP(인터페이스 분리 원칙) : 인터페이스 내에 메서드는 최소한 일수록 좋다.(하나의 일반적인 인터페이스보다 여러 개의 구체적인 인터페이스가 낫다.) SRP같이 책임 과다에 대한 또 다른 해결책
    5. DIP(의존관계 역전 원칙) : 구체적인 클래스보다 인터페이스, 추상클래스와 같이 변하지 않을 가능성이 높은 클래스와 관계를 맺어라. DIP 원칙을 따르는 가장 인기 있는 방법은 의존성 주입(DI)이다.
    
    ⇒ SOLID 원칙은 개발 과정에서 문제를 예방하고, 코드의 재사용성을 높이며, 유지보수를 용이하게 하는 데 도움 줌.
    
    **DI** : 객체가 직접 의존성을 생성하지 않고, 외부에서 주입받는 방식
    
    ```java
    public class Main {
        public static void main(String[] args) {
            InputDevice keyboard = new Keyboard();  
            Computer computer = new Computer(keyboard);  // **DI 적용 (의존성 주입)**
    
            computer.use(); // "타이핑 중..." 출력
        }
    }
    ```
    
<br/>

- **Call by Value vs Call by Reference**
    
    메서드를 호출할 때 파라미터를 전달하는 방식
    
    **Call by Value** (Java 동작법)
    
    메서드 호출 시 값을 넘겨줌. 호출자의 변수와 수신자의 파라미터는 복사된 서로 다른 변수. 값만 전달하기 때문에 수신자의 파라미터를 수정해도 호출자의 변수에는 영향 없음
    
    **Call by Reference**
    
    참조(주소)를 직접 전달. 주소를 직접 넘기기 때문에 호출자의 변수와 수신자의 파라미터는 완전히 동일한 변수. 메서드 내에서 파라미터를 수정하면 원본 변수에도 반영됨.
    
<br/>

- **Stream과 반복문 for문의 성능차이**
    
    성능은 Stream보다 for문이 더 좋습니다. for-loop는 십수년간 JVM에서 내부 최적화가 잘 되어있는 반면, Stream은 java8 출시와 함께 나온 개념이기에 최적화가 덜 되어있을 뿐더러 람다와 내부 반복과 같은 추가적인 연산으로 느립니다. 하지만, 함수형 코드로 짧고 직관적이어서 가독성이 높고 유지보수가 용이하다는 장점이 있습니다.
    
<br/>

- **JVM의 메모리 구조**
    
    JVM은 자바 파일을 운영체제에서 동작할 수 있도록 하는 가상머신. 프로그램 실행 중 데이터 관리, 메모리 할당 및 해제를 하기 위한 여러 구역으로 나누어짐. 크게 메서드 영역 / 힙 영역 / 스택 영역 / PC레지스터 / 네이티브 메소드 스택으로 나눌 수 있음.
    
    1. 메서드 영역 : 모든 쓰레드가 공유하는 메모리 영역. 클래스/인터페이스/메소드/필드/static변수 등 바이트 코드 보관
    2. 힙 영역 : JVM에서 객체를 생성하고 메모리를 관리하는 영역으로, GC 수행됨 (new로 생성된 객체 저장)
    3. 스택 영역 : 메서드 호출 시 지역 변수와 호출 정보를 임시적으로 저장하는 영역으로, 메서드 수행이 끝나면 삭제됨
    4. PC레지스터 : 현재 실행 중인 쓰레드가 어떤 명령어를 실행할지에 대한 정보를 저장하는 영역으로, 실행할 명령어의 주소를 가짐
    5. Native Method Stack : 자바 외 언어로 작성된 코드를 실행할 때 필요한 정보를 저장하는 영역

<br/>

- **자바의 Synchronized 키워드**
    
    여러 개의 쓰레드가 하나의 자원을 사용하고자 할 때, 현재 데이터를 사용하고 있는 쓰레드를 제외한 나머지 쓰레드들은 데이터에 접근할 수 없게 막는 개념. 멀티 쓰레드 환경에서 쓰레드 간 동기화(같은 자원에 접근 못하도록 순서 조정)를 통해 데이터의 thread-safe를 보장함.
    
<br/>

- **제네릭**
    
    클래스나 메서드를 선언할 때 타입을 지정하지 않고, 사용할 때 타입을 결정하는 기능.(클래스 내부가 아닌 외부에서 데이터 타입 지정) 즉, 컴파일 시 타입을 강제함으로써 타입 안정성을 보장할 수 있음.
    
    단, 런타임에서는 타입 정보가 손실되어, 타입별로 다르게 동작하는 로직 만들기 어렵다는 단점
    
<br/>

- **Optional**
    
    Optional이란 null을 안전하게 처리하는 방법.
    
    이점 : NullPointException을 방지할 수 있고, orElse/orElseThrow 등을 사용해 명시적인 null 예외처리 또는 기본 값 반환할 수 있음.
    
    주의점 : 멤버변수(필드) 또는 매개변수와 같이 유의미한 값이 존재해야하는 경우 코드의 복잡성이 증가하기 때문에 사용하지 말아야 함.(매개변수 예외 처리 어려움)
    
    .get → .isPresent
    
<br/>

- **Java의 데이터 타입**
    
    크게 **기본 타입**과 **참조 타입**으로 나뉨.
    
    **기본타입** : 값을 직접 저장하는 타입으로 메모리 사용 효율적 / 스택에 저장
    int, long, float, double 등
    
    **참조타입** : 객체의 주소를 저장하는 타입 / 힙에 저장, 참조 주소는 스택에 저장
    String, Array, Class, Interface 등
    
    - **wrapper클래스는?**
        
        기본형 데이터를 객체로 감싸는 클래스. 기본형 데이터를 객체터럼 다룰 필요가 있을 때 사용
  
 <br/>


- **static 클래스(정적 클래스)**
    
    클래스 내부의 모든 멤버(변수와 메서드)가 static으로 선언된 클래스.
    자바에서는 정적 클래스 자체는 존재하지 않지만, 정적 멤버만 가지는 클래스를 정적 클래스 처럼 사용할 수 잇음
    - 객체를 생성하지 않고 사용 가능(new 없이 바로 접근)
    - 클래스 로딩 시 한 번만 메모리에 올라감(싱글톤처럼 동작)
    - 공유 목적으로 사용
    
    ```java
    public class MathUtil {
        // private 생성자로 객체 생성 방지
        private MathUtil() {}
    
        // 정적 메서드 (객체 생성 없이 사용 가능)
        public static int add(int a, int b) {
            return a + b;
        }
    
        public static int multiply(int a, int b) {
            return a * b;
        }
    }
    
    public class Main {
        public static void main(String[] args) {
            int sum = MathUtil.add(10, 20); // 객체 생성 없이 사용
            int product = MathUtil.multiply(5, 6);
    
            System.out.println("덧셈 결과: " + sum); // 30
            System.out.println("곱셈 결과: " + product); // 30
        }
    }
    ```
    
<br/>

- **Java의 접근제어자(접근제한자)**
    
    변수 또는 메서드의 접근 범위를 설정해주기 위해 사용하며, 총 4가지가 있음
    
    1. public : 접근 제한 없음. 같은 플젝 내 어디서든 사용 가능
    2. protected : 해당 패키지 내, 다른 패키지에서 상속받아 자식 클래스에서 접근 가능
    3. default : 해당 패키지 내에서만 접근 가능
    4. private : 해당 클래스에서만 접근 가능

<br/>

- **오버로딩 vs 오버라이딩**
    
    **오버로딩**
    
    같은 클래스에서 같은 이름의 메서드를 매개변수의 개수나 타입, 순서를 다르게 해 여러 개 정의 (반환 타입만 다른 건 오버로딩 아님)
    
    **오버라이딩**
    
    부모 클래스의 메서드를 자식 클래스에서 재정의. 상속 관계에서만 발생
